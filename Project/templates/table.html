{% load static %}
{%block content%}
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Teen Patti Table</title>
    <link rel="stylesheet" type="text/css" href="{% static 'css/table.css' %}">
    <style>
        #timer {
    font-weight: bold;
    text-align: center;
    }
    #timer-countdown {
        font-weight: bold;
    }
</style>
</head>
<body>
    <div class="container">
        {% comment %} <button class="exit-game-btn" id="exit-game-btn">Exit Game</button>
        {% endcomment %}
        
        <div class="poker-table">
            <!-- Top Icons -->
            <div class="top-icons">
                <button class="icon-button">ℹ</button>
                <button class="icon-button">⚙</button>
            </div>
            
            <!-- Poker Table -->
            <div class="table">
                <p>User ID: {{ user.id }}</p>

                <!-- Players -->
                <div class="players-grid">
                    {% for player in players %}
                    <div class="player" id="player-{{ player.id }}">
                        <img src="{{ player.avatar }}" alt="Image" class="player-img">
                        <div class="player-info">

                            <div class="player-name">{{ player.username }}</div>
                            <div class="player-coins"> {{ player.coins }}</div> 
                            <div class="player-current-bet" id="player-current-bet-{{ player.id }}">♦ {{ player.current_bet }}</div> <!-- Add this line -->
                        </div>
                        <!-- Player Cards -->
                        <div class="player-cards" id="player-cards-{{ player.id }}" style="display: none;">
                            {% if player.id == user.id and not player.is_blind %}
                                {% for card in player.cards %}
                                    <span class="card">{{ card }}</span>
                                {% endfor %}
                            {% else %}
                                <span class="card">Hidden</span>
                            {% endif %}
                        </div>
                             <!-- Show "See Cards" Button only for the player viewing the page -->    
                        {% if player.id == user.id %}
                        <button class="see-cards" id="see-cards-btn-{{ player.id }}" onclick="toggleSeen({{ player.id }})"
                            {% if not player.is_blind %}style="display: none;"{% endif %}>
                            See Cards
                        </button>
                    {% endif %}
                    </div>
                    {% endfor %}
                </div>
             
                <!-- Center Content -->
                <div class="center-content">
                    <div class="table-limit">Table Limit</div>
                    <div class="table-pot">120,000</div>
                    <div class="table-current-bet">♦ 12,800</div>
                    <div class="progress-bar"><div class="progress"></div>
                </div>
                    <div id="game-log"></div>
                    <div id="timer" style="display: none; font-size: 1.2em; color: red; margin-top: 10px;">
                        Time left: <span id="timer-countdown">30</span> seconds
                    </div>
                </div>
            </div>
            
            <!-- Bottom Controls -->
            <div class="controls" id="controls">
                <button class="control-button red" id="pack-btn" onclick="packGame()">Pack</button>
                <button class="control-button purple" id="sideshow-btn" onclick="requestSideshow()">Sideshow</button>
                <button class="control-button blue" id="bet-btn">Bet</button> 
                <button class="control-button blue" id="double-bet-btn">Double Bet</button>
                <button class="control-button green" id="show-btn" onclick="requestShow()">Show</button>
            </div>
            <div id="show-result" style="display: none;"></div>
        </div>
    </div>
</body>
</html>
{% endblock content%}
<script>
    let currentUserId = "{{ user.id }}";  // Store Django user ID in JavaScript
   console.log("Loading Javascript");
    let gameRoomId = "{{ game_room_id }}";  // Ensure this value is correctly rendered from the context
    console.log("Game Room ID:", gameRoomId);
    let playersData = [];  // Store the latest players data globally
    let currentTurn = 0;
    let round_status = "";  // Ensure this is globally accessible
    let cardsToggled = false;  // Tracks if "See Cards" has been clicked
    let localHandCards = [];   // Stores cards locally after toggle
    let activeSideshowKey = null; // Track the current sideshow request
    let timerInterval = null; // Track timer interval
const socket = new WebSocket(`ws://${window.location.host}/ws/game/${gameRoomId}/`);

socket.onopen = function(e) {
    console.log("Connected to game room");
};

socket.onmessage = function(e) {
    const data = JSON.parse(e.data);
    console.log("Received game data:", data);
    console.log("Keys in received data:", Object.keys(data));
    if (data.error){
        updateGameUI(data.error);
        setTimeout(() => {
            window.location.href = '/gamedevelopment/interface/'; // Redirect to lobby
        }, 3000); // Show error for 3 seconds before redirect
        return;
    }
    if (data.type === "game_update") {
        currentTurn = data.current_turn;
        round_status = data.round_status;
        console.log("Round Status:", round_status);
        if (data.round_status === "distribution") {
            console.log("New round detected. Resetting card visibility.");
            cardsToggled = false;
            localHandCards = [];
            document.getElementById("pack-btn").disabled = true;
            document.getElementById("sideshow-btn").disabled = true;
            document.getElementById("bet-btn").disabled = true;
            document.getElementById("double-bet-btn").disabled = true;
            const controls = document.getElementById("controls");
            controls.style.display = "none";
        

            // Clear cards for ALL players and reset their UI
            playersData.forEach(player => {
                const cardsContainer = document.querySelector(`#player-cards-${player.id}`);
                if (cardsContainer) {
                    cardsContainer.innerHTML = "";
                    cardsContainer.style.display = "none";
                }

                // Reset or show See Cards button for current user
                const playerElement = document.querySelector(`#player-${player.id}`);
                let seeButton = document.querySelector(`#see-cards-btn-${player.id}`);
                if (player.id == currentUserId && !player.is_spectator) {
                    if (!seeButton) {
                        seeButton = document.createElement("button");
                        seeButton.className = "see-cards-btn";
                        seeButton.id = `see-cards-btn-${player.id}`;
                        seeButton.textContent = "See Cards";
                        seeButton.onclick = () => toggleCards(player.id);
                        if (playerElement) playerElement.appendChild(seeButton);
                    } else {
                        seeButton.style.display = "block";
                    }
                } else {
                    // Hide other players' see cards button if any (precaution)
                    if (seeButton) {
                        seeButton.style.display = "none";
                    }
                }
            });
        }

        if (data.players) {
            playersData = data.players; // Update global players data
            updatePlayersList(data.players);
            updateControls(data);
            updateGameUI(data);
            updateBetButton(data); // Update the bet button text dynamically
            updateDoubleBetButton(data); // Update the double bet button text dynamically
        }
    } else if (data.type === "spectator_notification") {
        // Display spectator notification
        updateGameUI(data.message);
    } else if (data.type === "sideshow_request") {
        if (Number(data.opponent_id) === Number(currentUserId)) {
            // Only show prompt if this is a new request
            if (activeSideshowKey !== data.sideshow_key) {
                activeSideshowKey = data.sideshow_key;
                showSideshowPrompt(data.requester_id);
            } else {
                console.log("Ignoring duplicate sideshow request:", data.sideshow_key);
            }
        }
    } else if (data.type === "sideshow_result") {
        updateGameUI(data.message);
        // Clear prompt and reset active key
        const prompt = document.getElementById("sideshow-prompt");
        if (prompt) prompt.remove();
        activeSideshowKey = null;
        const sideshowBtn = document.getElementById("sideshow-btn");
        console.log(`Sideshow button status after sideshow_result: disabled=${sideshowBtn.disabled}, display=${sideshowBtn.style.display}`);
    } else if (data.type === "show_result") {
        winnerprompt(data);
    }else if (data.type === "timer_start") {
        if (!playersData.length) {
            console.warn("playersData not initialized for timer_start, waiting for game_update");
            return;
        }
        handleTimerStart(data);
    }else if (data.type === "player_packed") {
        updateGameUI(data.message);
        stopTimer();
     } else if (data.type === "player_disconnected") {
        // Handle player leaving scenario
        console.log(`Player ${data.player_id} has disconnected.`);
        removePlayerFromUI(data.player_id);
    } else if (data.message) {
        updateGameUI(data.message);
    } else {
        console.error("No players data received or unrecognized data type!");
    }
};

socket.onclose = function(e) {
    console.log("Disconnected. Attempting to reconnect...");
    setTimeout(function() {
       window.location.href = '/gamedevelopment/interface/'; // Redirect to home page
    }, 1000);
};


function updatePlayersList(players) {
    console.log("updatePlayersList called with players:", players);
    const playerList = document.querySelector(".players-grid");
    const existingPlayerIds = new Set(Array.from(playerList.children).map(child => child.id.replace('player-', '')));

    players.forEach(player => {
        console.log(`Processing player: ${player.id}`);
        let playerElement = document.querySelector(`#player-${player.id}`);

        const isCurrentUser = player.id == currentUserId;
        const shouldShowCards = isCurrentUser && !player.is_blind && !player.is_spectator;
        const cardsToggled = !player.is_blind;

        if (playerElement) {
            // === Update existing player ===
            console.log(`Updating existing player ${player.id}`);
            let imgElement = playerElement.querySelector('.player-img');
            if (!imgElement) {
                imgElement = document.createElement('img');
                imgElement.className = 'player-img';
                imgElement.alt = "Image";
                playerElement.insertBefore(imgElement, playerElement.firstChild);
            }
            imgElement.src = player.avatar || "/media/avatars/default.png";

            const playerInfo = playerElement.querySelector('.player-info');
            if (playerInfo) {
                playerInfo.querySelector('.player-name').textContent = player.username;
                playerInfo.querySelector('.player-coins').textContent = `♦ ${player.coins}`;
                playerInfo.querySelector('.player-current-bet').textContent = `♦ ${player.current_bet}`;

                let packStatus = playerInfo.querySelector('.player-pack-status');
                if (!packStatus) {
                    packStatus = document.createElement('div');
                    packStatus.className = 'player-pack-status';
                    playerInfo.appendChild(packStatus);
                }
                packStatus.textContent = player.is_spectator ? "Spectator" : (player.is_packed ? "Packed" : "");
            }

            playerElement.className = `player ${player.position}`;
            playerElement.setAttribute('data-player-id', player.id);

            const cardsEl = playerElement.querySelector(`#player-cards-${player.id}`);
            const seeCardsBtn = playerElement.querySelector(`#see-cards-btn-${player.id}`);

            if (cardsEl) {
                const previousDisplay = cardsEl.style.display;

                if (shouldShowCards) {
                    cardsEl.style.display = 'block';
                    const cardsToDisplay = (cardsToggled && player.cards.length === 0 && localHandCards.length > 0)
                        ? localHandCards
                        : player.cards;
                    cardsEl.innerHTML = cardsToDisplay.map(card => `<span class="card">${card}</span>`).join('');
                    if (seeCardsBtn) seeCardsBtn.style.display = 'none';
                    console.log(`Player ${player.id} card visibility: Shown`);
                } else {
                    cardsEl.style.display = 'none';
                    cardsEl.innerHTML = '<span class="card">Hidden</span>'; // Optional placeholder
                    if (seeCardsBtn && !player.is_spectator && round_status === "betting") seeCardsBtn.style.display = 'block';
                    console.log(`Player ${player.id} card visibility: Hidden`);
                }
            }

            if (isCurrentUser && !player.is_spectator) {
                if (!seeCardsBtn && player.is_blind && round_status === "betting") {
                    const newBtn = document.createElement('button');
                    newBtn.className = "see-cards-btn";
                    newBtn.id = `see-cards-btn-${player.id}`;
                    newBtn.textContent = "See Cards";
                    newBtn.onclick = () => toggleCards(player.id);
                    playerElement.appendChild(newBtn);
                }
            }else if (seeCardsBtn) {
                seeCardsBtn.style.display = 'none'; // Hide for spectators
            }
            existingPlayerIds.delete(player.id.toString());
        } else {
            // === Add new player ===
            console.log(`Adding new player: ${player.id}`);
            const playerDiv = document.createElement('div');
            playerDiv.classList.add('player', player.position);
            playerDiv.id = `player-${player.id}`;
            playerDiv.setAttribute('data-player-id', player.id);

            let buttonHTML = "";
            if (isCurrentUser && !player.is_spectator && !cardsToggled && round_status === "betting") {
                buttonHTML = `<button class="see-cards-btn" id="see-cards-btn-${player.id}" onclick="toggleCards(${player.id})">See Cards</button>`;
            }

            const cardDisplay = shouldShowCards ? 'block' : 'none';
            const cardsToDisplay = (cardsToggled && player.cards.length === 0 && isCurrentUser)
                ? localHandCards
                : (shouldShowCards ? player.cards : []);

            const cardsHTML = shouldShowCards
                ? cardsToDisplay.map(card => `<span class="card">${card}</span>`).join('')
                : `<span class="card">Hidden</span>`;

            playerDiv.innerHTML = `
                <img src="${player.avatar || '/media/avatars/default.png'}" alt="Image" class="player-img">
                <div class="player-info">
                    <div class="player-name">${player.username}</div>
                    <div class="player-coins">♦ ${player.coins}</div>
                    <div class="player-current-bet" id="player-current-bet-${player.id}">♦ ${player.current_bet}</div>
                    <div class="player-pack-status">${player.is_spectator ? "Spectator" : (player.is_packed ? "Packed" : "")}</div>
                </div>
                <div class="player-cards" id="player-cards-${player.id}" style="display:${cardDisplay};">
                    ${cardsHTML}
                </div>
                ${buttonHTML}
            `;
            playerList.appendChild(playerDiv);

            updatePlayerCards(player.id, shouldShowCards ? cardsToDisplay : []);
            console.log(`New player ${player.id} appended to DOM`);
        }
    });

    // === Remove stale players ===
    existingPlayerIds.forEach(id => {
        const staleElement = document.querySelector(`#player-${id}`);
        if (staleElement) {
            console.log(`Removing stale player: ${id}`);
            staleElement.remove();
        }
    });
}


// Function to toggle the visibility of the player's cards
function toggleCards(playerId) {
    const cardsContainer = document.querySelector(`#player-cards-${playerId}`);
    const seeButton = document.querySelector(`#see-cards-btn-${playerId}`);

    cardsContainer.style.display = "block";
    cardsToggled = true;

    const currentPlayer = playersData.find(p => Number(p.id) === Number(currentUserId));
    if (currentPlayer && currentPlayer.cards.length > 0) {
        localHandCards = [...currentPlayer.cards];  // Store cards locally
    }

    if (seeButton) seeButton.style.display = "none";

    const data = {
        action: 'toggle_seen',
        player_id: currentUserId
    };
    socket.send(JSON.stringify(data));
}


function updatePlayerCards(playerId, cards) {
    const playerCardsContainer = document.querySelector(`#player-cards-${playerId}`);
    if (!playerCardsContainer) return;

    const isCurrentUser = playerId == currentUserId;
    const currentPlayer = playersData.find(p => Number(p.id) === Number(playerId));

    if (currentPlayer.is_spectator) {
        playerCardsContainer.innerHTML = "";
        playerCardsContainer.style.display = "none";
        return;
    }

    // Handle current user's card visibility
    if (isCurrentUser) {
    if (cardsToggled) {
        if (cards.length === 0 && localHandCards.length > 0) {
            cards = localHandCards;
        } else if (cards.length > 0) {
            localHandCards = [...cards];
        }
    } else {
        localHandCards = [];
        cards = []; // ⬅ force no card reuse
    }
}


    //  Always clear DOM (even if cards are empty)
    playerCardsContainer.innerHTML = "";

    cards.forEach(card => {
        const cardElement = document.createElement('div');
        cardElement.classList.add('card');
        cardElement.textContent = card;
        playerCardsContainer.appendChild(cardElement);
    });

    // Only show if player toggled and has cards
    const shouldShow = isCurrentUser && cardsToggled && cards.length > 0;
    playerCardsContainer.style.display = shouldShow ? "block" : "none";

    console.log(`Player ${playerId} card visibility: ${shouldShow ? "Shown" : "Hidden"}`);
}

function updateGameUI(data) {
    const gameLog = document.getElementById("game-log");
    
    console.log("Updating game UI with data:", data);
    if (typeof data === "string") {
        const statusDiv = document.getElementById("game-status");
        if (!statusDiv) {
            const newStatusDiv = document.createElement("div");
            newStatusDiv.id = "game-status";
            newStatusDiv.style.position = "fixed";
            newStatusDiv.style.top = "10px";
            newStatusDiv.style.left = "50%";
            newStatusDiv.style.transform = "translateX(-50%)";
            newStatusDiv.style.background = "rgba(0, 0, 0, 0.8)";
            newStatusDiv.style.color = "white";
            newStatusDiv.style.padding = "10px";
            newStatusDiv.style.borderRadius = "5px";
            document.body.appendChild(newStatusDiv);
        }
        document.getElementById("game-status").textContent = data;
        setTimeout(() => {
            const statusDiv = document.getElementById("game-status");
            if (statusDiv) statusDiv.remove();
        }, 5000); // Hide after 5 seconds
        return;
    }
    if(data.message){
        const messageElement = document.createElement("p");
        messageElement.textContent = data.message;
        gameLog.appendChild(messageElement);
        gameLog.scrollTop = gameLog.scrollHeight;
        setTimeout(() => {
        messageElement.remove();
    }, 3000)
    }
    console.log("table-pot", data.table_pot);
    console.log("pot", data.pot);
    const tablePotElement = document.querySelector(".table-pot");
    if (tablePotElement && data.pot !== undefined) {  
        tablePotElement.textContent = `♦ ${data.table_pot}`;
    }
    const currentBetElement = document.querySelector(".table-current-bet");
    if (currentBetElement && data.pot !== undefined) {
        currentBetElement.textContent = `♦ ${data.pot}`;
    }
}

function handleTimerStart(data) {
    console.log(`handleTimerStart: player_id=${data.player_id}, duration=${data.duration}, currentUserId=${currentUserId}`);
    const timerDiv = document.getElementById("timer");
    const timerCountdown = document.getElementById("timer-countdown");
    const player = playersData.find(p => Number(p.id) === Number(data.player_id));

    if (!player) {
        console.error(`Player ${data.player_id} not found in playersData`);
        timerDiv.style.display = "none";
        return;
    }

    if (!timerCountdown) {
        console.error("timer-countdown element not found in DOM");
        timerDiv.style.display = "none";
        return;
    }

    // Update timer display without overwriting timerCountdown
    timerDiv.style.display = "block";
    timerDiv.childNodes[0].textContent = `Time left for ${player.username}: `;
    timerCountdown.textContent = data.duration;

    stopTimer(); // Clear any existing timer
    let timeLeft = data.duration;
    timerInterval = setInterval(() => {
        timeLeft--;
        console.log(`Timer tick: ${timeLeft} seconds left for ${player.username}`);
        if (timerCountdown) {
            timerCountdown.textContent = timeLeft;
        } else {
            console.error("timerCountdown element lost in interval");
            stopTimer();
            return;
        }
        if (timeLeft <= 0) {
            console.log(`Timer expired for ${player.username}`);
            stopTimer();
            timerDiv.style.display = "none";
        }
    }, 1000);
}

function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
}

function updateControls(data) {
    console.log("updateControls:", { 
        round_status: data.round_status, 
        currentTurn: data.current_turn, 
        currentUserId, 
        playerAtTurn: data.players && data.current_turn < data.players.length ? data.players[data.current_turn] : null 
    });

    const controls = document.getElementById("controls");
    const seeCardsBtn = document.querySelector(`#see-cards-btn-${currentUserId}`);
    const players = data.players || [];
    const activePlayers = data.active_players || [];
    const round_status = data.round_status;
    const currentTurnIndex = data.current_turn;

    // Find current player
    const currentPlayer = players.find(p => Number(p.id) === Number(currentUserId));

    // Check if current player exists and is a spectator
    if (!currentPlayer || currentPlayer.is_spectator) {
        controls.style.display = "none";
        if (seeCardsBtn) seeCardsBtn.style.display = "none";
        document.getElementById("timer").style.display = "none"; // Hide timer
        stopTimer();
        console.log("Controls hidden: Current player is a spectator or not found");
        return;
    }

    // Map current_turn (index into players) to active player ID
    let currentTurnPlayerId = null;
    if (players[currentTurnIndex] && activePlayers.includes(Number(players[currentTurnIndex].id))) {
        currentTurnPlayerId = Number(players[currentTurnIndex].id);
    }

    // Find previous active player for sideshow logic
    let prevPlayer = null;
    let prevTurnIndex = (currentTurnIndex - 1 + players.length) % players.length;
    let searched = 0;
    while (searched < players.length) {
        const candidate = players[prevTurnIndex];
        if (candidate && activePlayers.includes(Number(candidate.id)) && !candidate.is_spectator && !candidate.is_packed) {
            prevPlayer = candidate;
            break;
        }
        prevTurnIndex = (prevTurnIndex - 1 + players.length) % players.length;
        searched++;
    }

    const isSideshowAllowed = activePlayers.length > 2 && !currentPlayer.is_blind && prevPlayer && !prevPlayer.is_blind;
    const showAllowed = activePlayers.length === 2;
    console.log("Sideshow check:", { 
        activePlayersLength: activePlayers.length, 
        currentBlind: currentPlayer.is_blind, 
        prevBlind: prevPlayer ? prevPlayer.is_blind : null, 
        prevPlayerId: prevPlayer ? prevPlayer.id : null 
    });

    const sideshowBtn = document.getElementById("sideshow-btn");
    const showBtn = document.getElementById("show-btn");
    const showAmount = prevPlayer
            ? (currentPlayer.is_blind || (!currentPlayer.is_blind && !prevPlayer.is_blind)
                ? prevPlayer.current_bet
                : 2 * prevPlayer.current_bet)
            : 1;
    // Show controls if it's the current player's turn and they're active
    if (round_status === "betting" && activePlayers.length > 0 && currentTurnPlayerId && 
        Number(currentTurnPlayerId) === Number(currentUserId) && !currentPlayer.is_packed) {        
        console.log("Player at current turn:", players[currentTurnIndex]);
        console.log("Player ID at current turn:", currentTurnPlayerId);
        controls.style.display = "block";
        document.getElementById("pack-btn").disabled = false;
        sideshowBtn.style.display = isSideshowAllowed ? "inline-block" : "none";
        showBtn.style.display = showAllowed ? "inline-block" : "none";
        showBtn.disabled = currentPlayer.coins < showAmount;
        document.getElementById("bet-btn").disabled = false;
        document.getElementById("double-bet-btn").disabled = false;
        if (seeCardsBtn && currentPlayer.is_blind) {
            seeCardsBtn.style.display = "block";
        }
        console.log("Controls displayed for current user. Sideshow allowed:", isSideshowAllowed);
    } else {
        controls.style.display = "none";
        if (seeCardsBtn) {
            seeCardsBtn.style.display = "none";
        }
        showBtn.disabled = true;
        showBtn.onclick = null;
        document.getElementById("timer").style.display = "none"; // Hide timer
        stopTimer();
        console.log("Controls hidden:", { round_status, currentTurnIndex, isPacked: currentPlayer?.is_packed });
    }

    console.log(`Sideshow button status in updateControls: disabled=${sideshowBtn.disabled}, display=${sideshowBtn.style.display}`);
}


function removePlayerFromUI(playerId) {
    console.log("Attempting to remove player with ID:", playerId); // Check player ID
    const playerElement = document.getElementById(`player-${playerId}`);
    console.log("Player element:", playerElement);  // Log player element
    if (playerElement) {
        playerElement.remove();
        console.log(`Player ${playerId} removed from UI`);
    }
}

document.addEventListener("DOMContentLoaded", () => {
    const packBtn = document.getElementById("pack-btn");
    const sideshowBtn = document.getElementById("sideshow-btn");

    // Remove existing listeners to prevent duplication
    packBtn.replaceWith(packBtn.cloneNode(true));
    sideshowBtn.replaceWith(sideshowBtn.cloneNode(true));

    // Reassign buttons after cloning
    const newPackBtn = document.getElementById("pack-btn");
    const newSideshowBtn = document.getElementById("sideshow-btn");

    newPackBtn.addEventListener("click", packGame);
    newSideshowBtn.addEventListener("click", requestSideshow);

    // Initialize buttons as disabled
    updateBetButton({ players: [], active_players: [], current_turn: 0 });
    updateDoubleBetButton({ players: [], active_players: [], current_turn: 0 });
});

let isBetting = false;

function updateBetButton(data) {
    console.log("updateBetButton:", { 
        round_status: data.round_status, 
        current_turn: data.current_turn, 
        currentUserId 
    });

    const betButton = document.getElementById("bet-btn");
    const players = data.players || [];
    const activePlayers = data.active_players || [];
    const currentTurnIndex = data.current_turn;
    const currentPlayer = players.find(p => Number(p.id) === Number(currentUserId));

    // Map current_turn to active player ID
    let currentTurnPlayerId = null;
    if (players[currentTurnIndex] && activePlayers.includes(Number(players[currentTurnIndex].id))) {
        currentTurnPlayerId = Number(players[currentTurnIndex].id);
    }

    if (
        currentPlayer && 
        activePlayers.length > 0 && 
        Number(currentTurnPlayerId) === Number(currentUserId)
    ) {
        // Find the previous active player
        let prevPlayer = null;
        let prevTurnIndex = (currentTurnIndex - 1 + players.length) % players.length;
        let searched = 0;
        while (searched < players.length) {
            const candidate = players[prevTurnIndex];
            if (candidate && activePlayers.includes(Number(candidate.id)) && !candidate.is_spectator && !candidate.is_packed) {
                prevPlayer = candidate;
                break;
            }
            prevTurnIndex = (prevTurnIndex - 1 + players.length) % players.length;
            searched++;
        }

        const minBet = currentPlayer.is_blind 
            ? (prevPlayer && prevPlayer.is_blind ? prevPlayer.current_bet : (prevPlayer ? prevPlayer.current_bet / 2 : 1))
            : (prevPlayer && prevPlayer.is_blind ? prevPlayer.current_bet * 2 : (prevPlayer ? prevPlayer.current_bet : 1));
        console.log(`Bet button - prevPlayer.current_bet: ${prevPlayer?.current_bet}, minBet: ${minBet}`);
        betButton.textContent = `Bet ${minBet}`;
        betButton.disabled = currentPlayer.coins < minBet;
        betButton.onclick = betButton.disabled ? null : () => placeBet(minBet);
    } else {
        betButton.textContent = "Bet";
        betButton.onclick = null;
        betButton.disabled = true; 
    }
}

function placeBet(amount) {
        if (isBetting) {
            console.log("Bet is already in progress. Please wait.");
            return;
        }
        const currentPlayer = playersData.find(p => Number(p.id) === Number(currentUserId));
        if (!currentPlayer) {
            console.error("Current player not found in playersData");
            updateGameUI("Error: Player data not found!");
            return;
        }

        if (currentPlayer.coins < amount) {
            updateGameUI(`Insufficient balance! Need ${amount}, have ${currentPlayer.coins}`);
            return;
        }
        isBetting = true;
        const data = {
            action: 'place_bet',
            player_id: currentUserId,
            amount: amount
        };
        socket.send(JSON.stringify(data));
        console.log("Bet placed:", amount);
        stopTimer(); // Stop timer on action
        document.getElementById("timer").style.display = "none";
        document.getElementById("bet-btn").disabled = true;
        setTimeout(() => {
            isBetting = false;
            document.getElementById("bet-btn").disabled = false;
        }, 1000);
    }


   // Add this function to update the Double Bet button text

   function updateDoubleBetButton(data) {
    console.log("updateDoubleBetButton:", { 
        round_status: data.round_status, 
        current_turn: data.current_turn, 
        currentUserId 
    });

    // Handle error messages from backend
    if (data.error) {
        console.error("Backend error:", data.error);
        alert("Game error: " + data.error);
        return;
    }

    const doubleBetButton = document.getElementById("double-bet-btn");
    const players = data.players || [];
    const activePlayers = data.active_players || [];
    const currentTurnIndex = data.current_turn;
    const currentPlayer = players.find(p => Number(p.id) === Number(currentUserId));

    // Map current_turn to active player ID
    let currentTurnPlayerId = null;
    if (players[currentTurnIndex] && activePlayers.includes(Number(players[currentTurnIndex].id))) {
        currentTurnPlayerId = Number(players[currentTurnIndex].id);
    }

    if (
        currentPlayer && 
        activePlayers.length > 0 && 
        Number(currentTurnPlayerId) === Number(currentUserId)
    ) {
        // Find the previous active player
        let prevPlayer = null;
        let prevTurnIndex = (currentTurnIndex - 1 + players.length) % players.length;
        let searched = 0;
        while (searched < players.length) {
            const candidate = players[prevTurnIndex];
            if (candidate && activePlayers.includes(Number(candidate.id)) && !candidate.is_spectator && !candidate.is_packed) {
                prevPlayer = candidate;
                break;
            }
            prevTurnIndex = (prevTurnIndex - 1 + players.length) % players.length;
            searched++;
        }

        const minBet = currentPlayer.is_blind 
            ? (prevPlayer && prevPlayer.is_blind ? prevPlayer.current_bet : (prevPlayer ? prevPlayer.current_bet / 2 : 1))
            : (prevPlayer && prevPlayer.is_blind ? prevPlayer.current_bet * 2 : (prevPlayer ? prevPlayer.current_bet : 1));
        const doubleAmount = currentPlayer.is_blind 
            ? (prevPlayer && prevPlayer.is_blind ? prevPlayer.current_bet * 2 : (prevPlayer ? prevPlayer.current_bet : 2))
            : (prevPlayer && prevPlayer.is_blind ? prevPlayer.current_bet * 4 : (prevPlayer ? prevPlayer.current_bet * 2 : 2));
        console.log(`Updated Double Bet button to: ${doubleAmount}`);
        doubleBetButton.textContent = `Double Bet ${doubleAmount}`;
        doubleBetButton.disabled = currentPlayer.coins < doubleAmount;
        doubleBetButton.onclick = doubleBetButton.disabled ? null : () => placeDoubleBet(doubleAmount);
    } else {
        doubleBetButton.textContent = "Double Bet";
        doubleBetButton.onclick = null;
        doubleBetButton.disabled = true;
    }
}

// Update placeDoubleBet to reflect the amount being sent
function placeDoubleBet(doubleAmount) {
    if (isBetting) {
        console.log("Bet is already in progress. Please wait.");
        return;
    }
    const currentPlayer = playersData.find(p => Number(p.id) === Number(currentUserId));
    if (!currentPlayer) {
        console.error("Current player not found in playersData");
        updateGameUI("Error: Player data not found!");
        return;
    }

    if (currentPlayer.coins < doubleAmount) {
        updateGameUI(`Insufficient balance for double bet! Need ${doubleAmount}, have ${currentPlayer.coins}`);
        return;
    }
    isBetting = true;
    socket.send(JSON.stringify({
        action: 'place_double_bet',
        player_id: currentUserId,
        amount: doubleAmount
    }));
    console.log(`Double bet placed: ${doubleAmount}`);
    stopTimer(); // Stop timer on action
    document.getElementById("timer").style.display = "none";
    document.getElementById("double-bet-btn").disabled = true;
    setTimeout(() => {
        isBetting = false;
        document.getElementById("double-bet-btn").disabled = false;
    }, 1000);
}

let isPacking = false;
 function packGame() {
    console.log("packGame triggered. Round status:", round_status, "Current user ID:", currentUserId);
    if (isPacking) {
        console.log("Pack action is already in progress. Please wait.");
        return;
    }
    if (round_status !== "betting") {
        console.log("Cannot pack: Game is not in betting state. Current state:", round_status);
        return;
    }
    const currentPlayer = playersData.find(p => Number(p.id) === Number(currentUserId));
    if (!currentPlayer || currentPlayer.is_packed || currentPlayer.is_spectator) {
        console.log("Cannot pack: Player is already packed or a spectator");
        return;
    }
    isPacking = true;
    const data = {
         action: 'pack',
         player_id: currentUserId
         // Player ID
     };
    socket.send(JSON.stringify(data));
    document.getElementById("pack-btn").disabled = true;
    updateGameUI("You have packed and folded this round.");
    setTimeout(() => {
        isPacking = false;
    }, 1000);
 }

 function showSideshowPrompt(requesterId) {     
    const requester = playersData.find(p => Number(p.id) === Number(requesterId));     
    const promptDiv = document.createElement("div");     
    promptDiv.id = "sideshow-prompt";     
    promptDiv.style.position = "fixed";     
    promptDiv.style.top = "50%";     
    promptDiv.style.left = "50%";     
    promptDiv.style.transform = "translate(-50%, -50%)";     
    promptDiv.style.background = "white";     
    promptDiv.style.padding = "20px";     
    promptDiv.style.border = "1px solid black";     
    promptDiv.style.boxShadow = "0px 4px 10px rgba(0, 0, 0, 0.3)"; // Adding shadow for better visibility
    
    promptDiv.innerHTML = `         
        <p id="sideshow-text" style="color: red; font-weight: bold; font-size: 18px;"> 
            ${requester.username} requests a sideshow. Accept?
        </p>         
        <button id="accept-sideshow">Yes</button>         
        <button id="decline-sideshow">No</button>     
    `;     

    document.body.appendChild(promptDiv);      

    document.getElementById("accept-sideshow").onclick = () => respondToSideshow(true);     
    document.getElementById("decline-sideshow").onclick = () => respondToSideshow(false); 
}

function respondToSideshow(accept) {
    const data = {
        action: "sideshow_response",
        player_id: currentUserId,
        accept: accept
    };
    socket.send(JSON.stringify(data));
    console.log(`Sideshow response: ${accept ? "Accepted" : "Declined"}`);
    document.getElementById("sideshow-prompt").remove();
    activeSideshowKey = null; // Reset after response
}
let isRequestingSideshow = false;
 function requestSideshow() {
    if (isRequestingSideshow) {
        console.log("Sideshow request is already in progress. Please wait.");
        return;
    }
    isRequestingSideshow = true;
    const activePlayers = playersData.filter(p => !p.is_packed);
    if (activePlayers.length <= 2) {
        console.log("Cannot request sideshow with 2 or fewer players");
        return;
    }
    const sideshowBtn = document.getElementById("sideshow-btn");
    if (sideshowBtn.disabled) {
        console.log("Sideshow button is disabled, request ignored");
        return;
    }
    const currentPlayerIndex = activePlayers.findIndex(p => Number(p.id) === Number(currentUserId));
    const prevPlayerIndex = (currentPlayerIndex - 1 + activePlayers.length) % activePlayers.length;
    const opponent = activePlayers[prevPlayerIndex];
    const opponentId = opponent.id;
    const currentPlayer = playersData.find(p => Number(p.id) === Number(currentUserId));
    const betAmount = opponent.current_bet; // Amount to match

    if (currentPlayer.coins < betAmount) {
            updateGameUI(`Insufficient balance for sideshow! Need ${betAmount}, have ${currentPlayer.coins}`);
            isRequestingSideshow = false;
            return;
        }
    const data = {
        action: 'sideshow',
        player_id: currentUserId,
        opponent_id: opponentId,
        amount: betAmount
    };
    socket.send(JSON.stringify(data));
    console.log(`Sideshow requested against Player ${opponentId} with bet ${betAmount}`);
    console.log(`Sideshow button status after request: disabled=${sideshowBtn.disabled}`);
    controls.style.display = "none";
    setTimeout(() => isRequestingSideshow = false, 1000);
}

function requestShow() {
    const currentPlayer = playersData.find(p => Number(p.id) === Number(currentUserId));
    if (!currentPlayer) {
        console.error("Current player not found in playersData");
        updateGameUI("Error: Player data not found!");
        return;
    }

    const players = playersData;
    const activePlayers = players.filter(p => !p.is_packed && !p.is_spectator);
    const currentTurnIndex = currentTurn;
    let prevPlayer = null;
    let prevTurnIndex = (currentTurnIndex - 1 + players.length) % players.length;
    let searched = 0;
    while (searched < players.length) {
        const candidate = players[prevTurnIndex];
        if (candidate && activePlayers.includes(Number(candidate.id)) && !candidate.is_spectator && !candidate.is_packed) {
                prevPlayer = candidate;
                break;
        }
        prevTurnIndex = (prevTurnIndex - 1 + players.length) % players.length;
        searched++;
        }

    const showAmount = prevPlayer
            ? (currentPlayer.is_blind || (!currentPlayer.is_blind && !prevPlayer.is_blind)
                ? prevPlayer.current_bet
                : 2 * prevPlayer.current_bet)
            : 1;

    if (currentPlayer.coins < showAmount) {
        updateGameUI(`Insufficient balance for show! Need ${showAmount}, have ${currentPlayer.coins}`);
        return;
    }
    const controls = document.getElementById("controls");
    const data = {
        action: 'show',
        player_id: currentUserId
    };
    socket.send(JSON.stringify(data));
    console.log("Show requested");
    stopTimer(); // Stop timer on action
    document.getElementById("timer").style.display = "none";
    controls.style.display = "none";

}
function winnerprompt(data) {
    const showResultDiv = document.getElementById("show-result");
    showResultDiv.style.display = "block";
    showResultDiv.innerHTML = `<p>${data.message}</p>`;
    setTimeout(() => {
        showResultDiv.style.display = "none";
    }, 5000); // Hide after 5 seconds
}
 document.getElementById("pack-btn").addEventListener("click", packGame);
 document.getElementById("sideshow-btn").addEventListener("click", requestSideshow); 

</script>